#!/usr/bin/env node

const SecurityTester = require('./security-tests');
const PenetrationTester = require('./penetration-test');
const ZAPSecurityScanner = require('./zap-security-scan');
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

class SecurityTestRunner {
    constructor() {
        this.results = {
            dependencyScan: null,
            securityTests: null,
            penetrationTests: null,
            zapScan: null,
            sonarQube: null
        };
        this.reportDir = './security-reports';
    }

    async runAllTests() {
        console.log('üîí INICIANDO SUITE COMPLETA DE PRUEBAS DE SEGURIDAD');
        console.log('='.repeat(80));
        console.log('Fecha:', new Date().toISOString());
        console.log('Proyecto: Sistema de Evaluaci√≥n ISTLA');
        console.log('='.repeat(80) + '\n');

        // Crear directorio para reportes
        if (!fs.existsSync(this.reportDir)) {
            fs.mkdirSync(this.reportDir, { recursive: true });
        }

        try {
            // 1. An√°lisis de dependencias
            await this.runDependencyScan();
            
            // 2. Pruebas de seguridad b√°sicas
            await this.runSecurityTests();
            
            // 3. Pruebas de penetraci√≥n
            await this.runPenetrationTests();
            
            // 4. Escaneo con OWASP ZAP (opcional)
            await this.runZAPScan();
            
            // 5. Verificar SonarQube (si est√° configurado)
            await this.checkSonarQube();
            
            // 6. Generar reporte final
            await this.generateFinalReport();
            
        } catch (error) {
            console.error('‚ùå Error durante las pruebas:', error);
        }
    }

    async runDependencyScan() {
        console.log('üì¶ 1. AN√ÅLISIS DE DEPENDENCIAS');
        console.log('-'.repeat(50));
        
        try {
            // NPM Audit
            console.log('üîç Ejecutando npm audit...');
            const auditResult = await this.executeCommand('npm audit --json');
            this.results.dependencyScan = JSON.parse(auditResult);
            
            console.log('‚úÖ An√°lisis de dependencias completado');
            
            // Mostrar resumen
            const vulnerabilities = this.results.dependencyScan.metadata.vulnerabilities;
            console.log(`üìä Vulnerabilidades encontradas:`);
            console.log(`  üî¥ Cr√≠ticas: ${vulnerabilities.critical || 0}`);
            console.log(`  üü† Altas: ${vulnerabilities.high || 0}`);
            console.log(`  üü° Medias: ${vulnerabilities.moderate || 0}`);
            console.log(`  üü¢ Bajas: ${vulnerabilities.low || 0}`);
            
        } catch (error) {
            console.error('‚ùå Error en an√°lisis de dependencias:', error.message);
        }
        
        console.log('');
    }

    async runSecurityTests() {
        console.log('üîí 2. PRUEBAS DE SEGURIDAD B√ÅSICAS');
        console.log('-'.repeat(50));
        
        try {
            const tester = new SecurityTester();
            await tester.runAllTests();
            this.results.securityTests = tester.results;
            
            console.log('‚úÖ Pruebas de seguridad b√°sicas completadas');
        } catch (error) {
            console.error('‚ùå Error en pruebas de seguridad:', error.message);
        }
        
        console.log('');
    }

    async runPenetrationTests() {
        console.log('üéØ 3. PRUEBAS DE PENETRACI√ìN');
        console.log('-'.repeat(50));
        
        try {
            const tester = new PenetrationTester();
            await tester.runAllTests();
            this.results.penetrationTests = tester.results;
            
            console.log('‚úÖ Pruebas de penetraci√≥n completadas');
        } catch (error) {
            console.error('‚ùå Error en pruebas de penetraci√≥n:', error.message);
        }
        
        console.log('');
    }

    async runZAPScan() {
        console.log('üï∑Ô∏è  4. ESCANEO CON OWASP ZAP');
        console.log('-'.repeat(50));
        
        try {
            // Verificar si ZAP est√° instalado
            const zapCheck = await this.executeCommand('zap --version');
            if (zapCheck) {
                const scanner = new ZAPSecurityScanner();
                const reportFile = await scanner.runBaselineScan();
                this.results.zapScan = reportFile;
                
                console.log('‚úÖ Escaneo ZAP completado');
            } else {
                console.log('‚ö†Ô∏è  OWASP ZAP no est√° instalado. Saltando escaneo ZAP.');
                console.log('üí° Para instalar ZAP: https://www.zaproxy.org/download/');
            }
        } catch (error) {
            console.log('‚ö†Ô∏è  OWASP ZAP no est√° disponible. Saltando escaneo ZAP.');
        }
        
        console.log('');
    }

    async checkSonarQube() {
        console.log('üîç 5. VERIFICACI√ìN DE SONARQUBE');
        console.log('-'.repeat(50));
        
        try {
            // Verificar si hay reportes de SonarQube
            const sonarReports = fs.readdirSync('.').filter(file => 
                file.includes('sonar') || file.includes('SonarQube')
            );
            
            if (sonarReports.length > 0) {
                console.log('‚úÖ Reportes de SonarQube encontrados:');
                sonarReports.forEach(report => console.log(`  üìÑ ${report}`));
                this.results.sonarQube = sonarReports;
            } else {
                console.log('‚ö†Ô∏è  No se encontraron reportes de SonarQube');
                console.log('üí° Ejecuta SonarQube para an√°lisis est√°tico de c√≥digo');
            }
        } catch (error) {
            console.log('‚ö†Ô∏è  No se pudieron verificar reportes de SonarQube');
        }
        
        console.log('');
    }

    async generateFinalReport() {
        console.log('üìä 6. GENERANDO REPORTE FINAL');
        console.log('-'.repeat(50));
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const reportFile = path.join(this.reportDir, `security-report-${timestamp}.md`);
        
        let report = `# Reporte de Seguridad - Sistema de Evaluaci√≥n ISTLA

**Fecha:** ${new Date().toISOString()}
**Proyecto:** Sistema de Evaluaci√≥n ISTLA
**Versi√≥n:** 1.0.0

## üìã Resumen Ejecutivo

`;

        // Resumen de vulnerabilidades
        let totalCritical = 0;
        let totalHigh = 0;
        let totalMedium = 0;
        let totalLow = 0;

        // Contar vulnerabilidades de dependencias
        if (this.results.dependencyScan) {
            const vulns = this.results.dependencyScan.metadata.vulnerabilities;
            totalCritical += vulns.critical || 0;
            totalHigh += vulns.high || 0;
            totalMedium += vulns.moderate || 0;
            totalLow += vulns.low || 0;
        }

        // Contar vulnerabilidades de pruebas de seguridad
        if (this.results.securityTests) {
            const securityVulns = this.results.securityTests.filter(r => r.status === 'VULNERABLE');
            securityVulns.forEach(v => {
                if (v.severity === 'HIGH') totalHigh++;
                else if (v.severity === 'MEDIUM') totalMedium++;
                else if (v.severity === 'LOW') totalLow++;
            });
        }

        // Contar vulnerabilidades de penetraci√≥n
        if (this.results.penetrationTests) {
            const penVulns = this.results.penetrationTests.filter(r => r.status === 'VULNERABLE');
            penVulns.forEach(v => {
                if (v.severity === 'CRITICAL') totalCritical++;
                else if (v.severity === 'HIGH') totalHigh++;
                else if (v.severity === 'MEDIUM') totalMedium++;
                else if (v.severity === 'LOW') totalLow++;
            });
        }

        report += `### üî¥ Vulnerabilidades Cr√≠ticas: ${totalCritical}
### üü† Vulnerabilidades Altas: ${totalHigh}
### üü° Vulnerabilidades Medias: ${totalMedium}
### üü¢ Vulnerabilidades Bajas: ${totalLow}

## üìä Detalles por Categor√≠a

### 1. An√°lisis de Dependencias

`;

        if (this.results.dependencyScan) {
            const vulns = this.results.dependencyScan.metadata.vulnerabilities;
            report += `- **Cr√≠ticas:** ${vulns.critical || 0}
- **Altas:** ${vulns.high || 0}
- **Medias:** ${vulns.moderate || 0}
- **Bajas:** ${vulns.low || 0}

`;
        } else {
            report += `No se pudo completar el an√°lisis de dependencias.

`;
        }

        report += `### 2. Pruebas de Seguridad B√°sicas

`;

        if (this.results.securityTests) {
            const vulns = this.results.securityTests.filter(r => r.status === 'VULNERABLE');
            const safe = this.results.securityTests.filter(r => r.status === 'SAFE');
            
            report += `- **Vulnerabilidades encontradas:** ${vulns.length}
- **Pruebas seguras:** ${safe.length}
- **Total de pruebas:** ${this.results.securityTests.length}

`;
        } else {
            report += `No se pudieron completar las pruebas de seguridad b√°sicas.

`;
        }

        report += `### 3. Pruebas de Penetraci√≥n

`;

        if (this.results.penetrationTests) {
            const critical = this.results.penetrationTests.filter(r => r.severity === 'CRITICAL');
            const high = this.results.penetrationTests.filter(r => r.severity === 'HIGH');
            const medium = this.results.penetrationTests.filter(r => r.severity === 'MEDIUM');
            const low = this.results.penetrationTests.filter(r => r.severity === 'LOW');
            
            report += `- **Cr√≠ticas:** ${critical.length}
- **Altas:** ${high.length}
- **Medias:** ${medium.length}
- **Bajas:** ${low.length}

`;
        } else {
            report += `No se pudieron completar las pruebas de penetraci√≥n.

`;
        }

        report += `### 4. Escaneo OWASP ZAP

`;

        if (this.results.zapScan) {
            report += `‚úÖ Escaneo completado
üìÑ Reporte: ${this.results.zapScan}

`;
        } else {
            report += `‚ö†Ô∏è No se pudo completar el escaneo ZAP

`;
        }

        report += `### 5. An√°lisis SonarQube

`;

        if (this.results.sonarQube && this.results.sonarQube.length > 0) {
            report += `‚úÖ Reportes encontrados:
`;
            this.results.sonarQube.forEach(reportFile => {
                report += `- ${reportFile}
`;
            });
        } else {
            report += `‚ö†Ô∏è No se encontraron reportes de SonarQube

`;
        }

        report += `## üéØ Recomendaciones

`;

        if (totalCritical > 0) {
            report += `### üî¥ CR√çTICO
- **Corregir inmediatamente** las vulnerabilidades cr√≠ticas
- Revisar y actualizar dependencias vulnerables
- Implementar parches de seguridad urgentes

`;
        }

        if (totalHigh > 0) {
            report += `### üü† ALTO
- **Priorizar** la correcci√≥n de vulnerabilidades altas
- Revisar configuraci√≥n de seguridad
- Implementar validaciones adicionales

`;
        }

        if (totalMedium > 0) {
            report += `### üü° MEDIO
- **Planificar** la correcci√≥n de vulnerabilidades medias
- Mejorar pr√°cticas de desarrollo seguro
- Implementar pruebas de seguridad automatizadas

`;
        }

        if (totalLow > 0) {
            report += `### üü¢ BAJO
- **Considerar** la correcci√≥n de vulnerabilidades bajas
- Mejorar documentaci√≥n de seguridad
- Implementar monitoreo continuo

`;
        }

        report += `## üìù Pr√≥ximos Pasos

1. **Revisar** todos los hallazgos de seguridad
2. **Priorizar** correcciones seg√∫n severidad
3. **Implementar** mejoras de seguridad
4. **Documentar** cambios realizados
5. **Re-ejecutar** pruebas despu√©s de correcciones
6. **Establecer** proceso de seguridad continua

## üîß Herramientas Utilizadas

- **NPM Audit:** An√°lisis de dependencias
- **Security Tests:** Pruebas automatizadas de seguridad
- **Penetration Tests:** Pruebas de penetraci√≥n
- **OWASP ZAP:** Escaneo de vulnerabilidades web
- **SonarQube:** An√°lisis est√°tico de c√≥digo

---
*Reporte generado autom√°ticamente por Security Test Runner*
`;

        // Guardar reporte
        fs.writeFileSync(reportFile, report);
        
        console.log(`‚úÖ Reporte final generado: ${reportFile}`);
        
        // Mostrar resumen final
        console.log('\nüìä RESUMEN FINAL');
        console.log('='.repeat(50));
        console.log(`üî¥ Cr√≠ticas: ${totalCritical}`);
        console.log(`üü† Altas: ${totalHigh}`);
        console.log(`üü° Medias: ${totalMedium}`);
        console.log(`üü¢ Bajas: ${totalLow}`);
        console.log(`üìÑ Reporte: ${reportFile}`);
        console.log('='.repeat(50));
    }

    executeCommand(command) {
        return new Promise((resolve, reject) => {
            exec(command, (error, stdout, stderr) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(stdout);
            });
        });
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    const runner = new SecurityTestRunner();
    runner.runAllTests().catch(console.error);
}

module.exports = SecurityTestRunner; 